<template>
  <div class="lazyload-all-box">
    <!-- 默认插槽：包裹需要懒加载的图片或图片所在的容器 -->
    <slot name="default"></slot>
  </div>
</template>

<script lang="ts">
// 从兼容 Vue2/Vue3 构建包的 vue-demi 库中导入组合式 Api
import {
  defineComponent,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  useSlots,
  isVue2,
  isVue3,
  type PropType,
  type VNode,
  getCurrentInstance,
} from 'vue-demi';

// 导入懒加载配置项参数 lazyOptions 和 observer 配置项参数
import { lazyOptionsObj, observerOptionsObj } from '@/scripts/lazy-observer-options';

// 导入 TS 类型声明
import { EImgCustAttr, EmitFunc, ILazyOptions, TModelValue } from '@/scripts/types';

// 【重点】导入实现图片懒加载的实现类
import { Lazy } from '@/scripts/lazy.class';

// 导入自定义的工具函数
import { deepCopy, waitLoadingImg } from '@/scripts/utils';

export default defineComponent({
  // 定义组件名字
  name: 'LazyLoadImgs',
  // 声明接收 props
  props: {
    // 用于接收支持 v-html 指令渲染 html 字符串数组的双向梆定参数
    modelValue: {
      type: [String, Array] as PropType<string | TModelValue>,
      required: false,
    },
    // 懒加载选项参数配置
    lazyOptions: {
      type: Object as PropType<ILazyOptions>,
      required: false,
      default: () => deepCopy(lazyOptionsObj),
    },
    // observer 选项参数配置
    observerOptions: {
      type: Object as PropType<IntersectionObserverInit>,
      required: false,
      default: () => deepCopy(observerOptionsObj),
    },
  },

  // 定义接收自定义事件或 v-model 双向梆定事件参数
  emits: ['update:modelValue'],

  // setup 钩子函数
  setup(props, { emit, attrs /* , slots */ }) {
    /******************** 生命周期钩子函数 - start ********************/
    /**
     * 本组件实例挂载前的钩子函数
     * 用于获取父组件（要使用本懒加载组件的上级组件）传过来的，要用于进行懒加载的容器里（如div）的所有图片，
     * 或直接传一个图片标签<img>进行懒加载的插槽内容
     */
    onBeforeMount(() => {
      // 【重点】Vue2/3 兼容写法：获取插槽内容；经测试 Vue2 中在此 onBeforeMount 钩子中直接使用 setup(props,{slots})
      // 解构的 slot.default 为空。Vue2 只能在选项式 methods 节点在 beforeMount 钩子里使用 this.$slots.default 获取，
      // 或如下使用 const app = getCurrentInstance(); const slots = app?.slots; 获取
      const slots = app?.slots;
      // 获取本组件的默认插槽的 vnodes
      const vnodes: VNode[] = isVue3 ? slots!.default?.()! : (slots?.default as any);
      console.log('slot vnodes:', vnodes);

      // 调用懒加载实现类对象的 setImgSrcToLoadingImg 方法递归处理默认插槽内的 img 标签虚拟节点，
      // 替换原来的 src 属性为 loadingImg，并将原图src设置到 data-orig-src 属性中
      dataImgIdList = lazy.setImgSrcToLoadingImg(vnodes, props.modelValue, emit as EmitFunc);
      // console.log('dataImgIdList:', dataImgIdList, instId);
    });

    /**
     * 本组件实例挂载后的钩子函数
     */
    onMounted(async () => {
      // 创建 observer
      imgObserver = lazy.createImgObserver();

      // 获取本组件每个实例需要开启监听的每个 img 元素（即使用本组件标签包裹起来的所有 img 标签集合）
      const allImgs = document.querySelectorAll(`img[${EImgCustAttr.IMG_ID}^=inst${instId}-]`);
      // console.log('allImgs:', allImgs, instId);

      // 1、由于使用 IntersectionObserver 实现懒加载图片时，调用其实例的 observe() 方法监听图片前，需要先设置图片对象的
      // width 和 height 属性或其 css 样式，否则默认宽高为0，会加载所有图片；
      // 所以，这里先使用自定义工具函数 createImgObjFromUrl 先创建并加载默认（或传过来的 props）的预加载图片 loadingImg 对象，
      // 等待创建完成，并显示预加载图片占用显示空间后，再使用 IntersectionObserver 实例的 observer() 方法监听图片，
      // 这样，不用预先设置图片的宽高样式，也能实现懒加载效果，但显示的懒加载图片大小与实际图片大小不一致。
      // 【因此强烈建议】：使用本组件前，为所有需要实现懒加载的图片设置 css 宽高样式）。
      const { img, err } = await waitLoadingImg(lazyOptions.loadingImg!, instId).catch((err) => err);
      // console.log('loadingImgObj, err, instId:', img, err, instId);

      // 2、然后，再循环开启监听每个 img 元素
      Array.prototype.forEach.call(allImgs, (imgEl: HTMLImageElement) => imgObserver.observe(imgEl));
    });

    /**
     * 本组件实例更新前的钩子函数
     */
    onBeforeUpdate(() => {
      // console.log('LazyLoadImgs onBeforeUpdate');
    });

    /**
     * 本组件实例更新后的钩子函数
     */
    onUpdated(() => {
      // console.log('LazyLoadImgs onUpdated');
    });

    /**
     * 本组件实例卸载前的钩子函数
     */
    onBeforeUnmount(() => {
      // 在卸载组件前，停止已经开启图片加载的延迟器
      const delayImgs = document.querySelectorAll(
        `img[${EImgCustAttr.IMG_ID}^=inst${instId}-][${EImgCustAttr.TIMEOUT_ID}]`
      );
      Array.prototype.forEach.call(delayImgs, (imgEl: HTMLImageElement) => lazy.clearLazyTimeout(imgEl));
    });

    /**
     * 本组件实例卸载后的钩子函数
     */
    onUnmounted(() => {
      // 组件卸载后，对应的实例ID数减一
      Lazy.instId--;

      // 停止监听所有图片进入交叉可视区状态
      imgObserver.disconnect();
    });
    /******************** 生命周期钩子函数 - end ********************/

    if (isVue2) {
      console.log('这里是 Vue2 环境...');
    } else if (isVue3) {
      console.log('这里是 Vue3 环境...');
    }

    // console.log('props:', props);

    // 把用户传过来的 Props 对象参数 lazyOptions 或 observerOptions 与默认的对象参数进行合并
    const lazyOptions: ILazyOptions = Object.assign({}, lazyOptionsObj, props.lazyOptions);
    const observerOptions: IntersectionObserverInit = Object.assign(
      {},
      observerOptionsObj,
      props.observerOptions
    );

    // 保存 <img> 标签里 data-img-id 属性值的数组
    let dataImgIdList: string[] = [];

    // 【重点】创建图片懒加载实现类 Lazy 的实例对象
    const lazy = new Lazy(lazyOptions, observerOptions);

    // 当前组件实例ID（Lazy 类静态属性ID）
    let instId = Lazy.instId;

    // 获取 Vue app 实例引用（兼容 Vue2 写法：用于在 onBeforeMount 中 app.slots 获取插槽内容）
    const app = getCurrentInstance();

    // 创建用于实现懒加载图片监听器的 IntersectionObserver 类的实例对象
    let imgObserver: IntersectionObserver;

    // 暴露内部变量在组件实例身上（可供外部读取）
    return {
      // 暴露本组件实例对应的实例ID（实则 Lazy 类的递增实例ID）
      instId,
    };
  },
});
</script>

<style lang="scss" scoped></style>
